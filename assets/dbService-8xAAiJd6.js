var S=Object.defineProperty;var h=(w,e,t)=>e in w?S(w,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):w[e]=t;var g=(w,e,t)=>h(w,typeof e!="symbol"?e+"":e,t);const b="CoExEvaluations";const c="samples";class y{constructor(){g(this,"db",null)}async init(){return this.db?this.db:new Promise((e,t)=>{const r=indexedDB.open(b,1);r.onerror=()=>{var n;t(new Error(`Failed to open database: ${(n=r.error)==null?void 0:n.message}`))},r.onsuccess=()=>{this.db=r.result,e(this.db)},r.onupgradeneeded=n=>{const d=n.target.result;if(!d.objectStoreNames.contains(c)){const a=d.createObjectStore(c,{keyPath:"id"});a.createIndex("sampleCode","sampleCode",{unique:!1}),a.createIndex("date","date",{unique:!1}),a.createIndex("evaluator","evaluator",{unique:!1}),a.createIndex("createdAt","createdAt",{unique:!1})}}})}generateUUID(){return typeof crypto<"u"&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=Math.random()*16|0;return(e==="x"?t:t&3|8).toString(16)})}async saveSample(e,t){const r=await this.init();return new Promise((n,d)=>{const s=r.transaction([c],"readwrite").objectStore(c),o=t||this.generateUUID(),l=Date.now(),i={...e,id:o,createdAt:l,updatedAt:l},u=s.put(i);u.onsuccess=()=>{n(o)},u.onerror=()=>{var m;d(new Error(`Failed to save sample: ${(m=u.error)==null?void 0:m.message}`))}})}async getSample(e){const t=await this.init();return new Promise((r,n)=>{const s=t.transaction([c],"readonly").objectStore(c).get(e);s.onsuccess=()=>{r(s.result||null)},s.onerror=()=>{var o;n(new Error(`Failed to get sample: ${(o=s.error)==null?void 0:o.message}`))}})}async getAllSamples(){const e=await this.init();return new Promise((t,r)=>{const s=e.transaction([c],"readonly").objectStore(c).index("createdAt").openCursor(null,"prev"),o=[];s.onsuccess=l=>{const i=l.target.result;i?(o.push(i.value),i.continue()):t(o)},s.onerror=()=>{var l;r(new Error(`Failed to get all samples: ${(l=s.error)==null?void 0:l.message}`))}})}async updateSample(e,t){const r=await this.init();return new Promise(async(n,d)=>{const a=await this.getSample(e);if(!a){d(new Error(`Sample with ID ${e} not found`));return}const o=r.transaction([c],"readwrite").objectStore(c),l={...a,...t,id:e,updatedAt:Date.now()},i=o.put(l);i.onsuccess=()=>{n()},i.onerror=()=>{var u;d(new Error(`Failed to update sample: ${(u=i.error)==null?void 0:u.message}`))}})}async deleteSample(e){const t=await this.init();return new Promise((r,n)=>{const s=t.transaction([c],"readwrite").objectStore(c).delete(e);s.onsuccess=()=>{r()},s.onerror=()=>{var o;n(new Error(`Failed to delete sample: ${(o=s.error)==null?void 0:o.message}`))}})}async deleteSamples(e){const t=await this.init();return new Promise((r,n)=>{const a=t.transaction([c],"readwrite").objectStore(c);let s=0,o=!1;e.forEach(l=>{const i=a.delete(l);i.onsuccess=()=>{s++,s===e.length&&!o&&r()},i.onerror=()=>{var u;o=!0,n(new Error(`Failed to delete sample ${l}: ${(u=i.error)==null?void 0:u.message}`))}}),e.length===0&&r()})}async exportAll(){return this.getAllSamples()}async importSamples(e){const t=await this.init();return new Promise((r,n)=>{const a=t.transaction([c],"readwrite").objectStore(c);let s=0,o=!1;e.forEach(l=>{const i=l.id||this.generateUUID(),u=Date.now(),m={...l,id:i,createdAt:l.createdAt||u,updatedAt:u},p=a.put(m);p.onsuccess=()=>{s++,s===e.length&&!o&&r()},p.onerror=()=>{var x;o=!0,n(new Error(`Failed to import sample: ${(x=p.error)==null?void 0:x.message}`))}}),e.length===0&&r()})}async searchBySampleCode(e){const t=await this.getAllSamples(),r=e.toLowerCase();return t.filter(n=>n.sampleCode.toLowerCase().includes(r))}async getSamplesByDateRange(e,t){const r=await this.init();return new Promise((n,d)=>{const o=r.transaction([c],"readonly").objectStore(c).index("date"),l=IDBKeyRange.bound(e,t),i=o.openCursor(l),u=[];i.onsuccess=m=>{const p=m.target.result;p?(u.push(p.value),p.continue()):n(u)},i.onerror=()=>{var m;d(new Error(`Failed to get samples by date range: ${(m=i.error)==null?void 0:m.message}`))}})}async clearAll(){const e=await this.init();return new Promise((t,r)=>{const a=e.transaction([c],"readwrite").objectStore(c).clear();a.onsuccess=()=>{t()},a.onerror=()=>{var s;r(new Error(`Failed to clear database: ${(s=a.error)==null?void 0:s.message}`))}})}}const f=new y;export{f as dbService};
