var h=Object.defineProperty;var b=(x,e,t)=>e in x?h(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t;var g=(x,e,t)=>b(x,typeof e!="symbol"?e+"":e,t);const S="CoExEvaluations";const i="samples";class y{constructor(){g(this,"db",null)}async init(){return this.db?this.db:new Promise((e,t)=>{const r=indexedDB.open(S,1);r.onerror=()=>{var n;t(new Error(`Failed to open database: ${(n=r.error)==null?void 0:n.message}`))},r.onsuccess=()=>{this.db=r.result,e(this.db)},r.onupgradeneeded=n=>{const u=n.target.result;if(!u.objectStoreNames.contains(i)){const l=u.createObjectStore(i,{keyPath:"id"});l.createIndex("sampleCode","sampleCode",{unique:!1}),l.createIndex("date","date",{unique:!1}),l.createIndex("evaluator","evaluator",{unique:!1}),l.createIndex("createdAt","createdAt",{unique:!1})}}})}generateUUID(){return typeof crypto<"u"&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=Math.random()*16|0;return(e==="x"?t:t&3|8).toString(16)})}async saveSample(e,t){const r=await this.init();return new Promise((n,u)=>{const s=r.transaction([i],"readwrite").objectStore(i),o=t||this.generateUUID(),a=Date.now(),c={...e,id:o,createdAt:a,updatedAt:a},d=s.put(c);d.onsuccess=()=>{n(o)},d.onerror=()=>{var m;u(new Error(`Failed to save sample: ${(m=d.error)==null?void 0:m.message}`))}})}async getSample(e){const t=await this.init();return new Promise((r,n)=>{const s=t.transaction([i],"readonly").objectStore(i).get(e);s.onsuccess=()=>{r(s.result||null)},s.onerror=()=>{var o;n(new Error(`Failed to get sample: ${(o=s.error)==null?void 0:o.message}`))}})}async getAllSamples(){const e=await this.init();return new Promise((t,r)=>{const s=e.transaction([i],"readonly").objectStore(i).index("createdAt").openCursor(null,"prev"),o=[];s.onsuccess=a=>{const c=a.target.result;c?(o.push(c.value),c.continue()):t(o)},s.onerror=()=>{var a;r(new Error(`Failed to get all samples: ${(a=s.error)==null?void 0:a.message}`))}})}async updateSample(e,t){const r=await this.init();return new Promise(async(n,u)=>{const l=await this.getSample(e);if(!l){u(new Error(`Sample with ID ${e} not found`));return}const o=r.transaction([i],"readwrite").objectStore(i),a={...l,...t,id:e,updatedAt:Date.now()},c=o.put(a);c.onsuccess=()=>{n()},c.onerror=()=>{var d;u(new Error(`Failed to update sample: ${(d=c.error)==null?void 0:d.message}`))}})}async deleteSample(e){const t=await this.init();return new Promise((r,n)=>{const s=t.transaction([i],"readwrite").objectStore(i).delete(e);s.onsuccess=()=>{r()},s.onerror=()=>{var o;n(new Error(`Failed to delete sample: ${(o=s.error)==null?void 0:o.message}`))}})}async deleteSamples(e){const t=await this.init();return new Promise((r,n)=>{const l=t.transaction([i],"readwrite").objectStore(i);let s=0,o=!1;e.forEach(a=>{const c=l.delete(a);c.onsuccess=()=>{s++,s===e.length&&!o&&r()},c.onerror=()=>{var d;o=!0,n(new Error(`Failed to delete sample ${a}: ${(d=c.error)==null?void 0:d.message}`))}}),e.length===0&&r()})}async exportAll(){return this.getAllSamples()}async importSamples(e){const t=await this.init();return new Promise((r,n)=>{const l=t.transaction([i],"readwrite").objectStore(i);let s=0,o=!1;e.forEach(a=>{const c=a.id||this.generateUUID(),d=Date.now(),m={...a,id:c,createdAt:a.createdAt||d,updatedAt:d},p=l.put(m);p.onsuccess=()=>{s++,s===e.length&&!o&&r()},p.onerror=()=>{var w;o=!0,n(new Error(`Failed to import sample: ${(w=p.error)==null?void 0:w.message}`))}}),e.length===0&&r()})}async searchBySampleCode(e){const t=await this.init(),r=e.toLowerCase();return new Promise((n,u)=>{const a=t.transaction([i],"readonly").objectStore(i).index("sampleCode").openCursor(),c=[];a.onsuccess=d=>{const m=d.target.result;if(m){const p=m.value;p.sampleCode.toLowerCase().includes(r)&&c.push(p),m.continue()}else n(c)},a.onerror=()=>{var d;u(new Error(`Failed to search samples: ${(d=a.error)==null?void 0:d.message}`))}})}async getSamplesByDateRange(e,t){const r=await this.init();return new Promise((n,u)=>{const o=r.transaction([i],"readonly").objectStore(i).index("date"),a=IDBKeyRange.bound(e,t),c=o.openCursor(a),d=[];c.onsuccess=m=>{const p=m.target.result;p?(d.push(p.value),p.continue()):n(d)},c.onerror=()=>{var m;u(new Error(`Failed to get samples by date range: ${(m=c.error)==null?void 0:m.message}`))}})}async clearAll(){const e=await this.init();return new Promise((t,r)=>{const l=e.transaction([i],"readwrite").objectStore(i).clear();l.onsuccess=()=>{t()},l.onerror=()=>{var s;r(new Error(`Failed to clear database: ${(s=l.error)==null?void 0:s.message}`))}})}}const f=new y;export{f as dbService};
